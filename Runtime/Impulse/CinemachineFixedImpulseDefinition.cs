using Cinemachine.Utility;
using UnityEngine;

namespace Cinemachine
{
    /// <summary>
    /// A definition of an impulse signal that gets propagated to listeners
    /// </summary>
    [DocumentationSorting(DocumentationSortingAttribute.Level.API)]
    [SaveDuringPlay]
    public class CinemachineFixedImpulseDefinition : CinemachineImpulseDefinition
    {
        /// <summary>
        /// This defines the time-envelope of the signal.  
        /// The raw signal generated by the profile will be scaled to fit in the envelope.
        /// </summary>
        [Tooltip("This defines the time-envelope of the signal.  The raw signal generated by the profile will be scaled to fit in the envelope.")]
        [CinemachineImpulseEnvelopeProperty]
        public CinemachineImpulseManager.EnvelopeDefinition m_ImpactEnvelope;

        /// <summary>
        /// The signal will have full amplitude in this radius surrounding the impact point.  
        /// Beyond that it will dissipate with distance.
        /// </summary>
        [Tooltip("The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]
        public float m_ImpactRadius = 1;

        /// <summary>
        /// This defines how the signal will dissipate with distance beyond the impact radius.  
        /// </summary>
        [Tooltip("This defines how the signal will dissipate with distance beyond the impact radius.")]
        public CinemachineImpulseManager.ImpulseEvent.DissipationMode m_DissipationMode 
            = CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;

        /// <summary>
        /// At this distance beyond the impact radius, the signal will have dissipated to zero.  
        /// </summary>
        [Tooltip("At this distance beyond the impact radius, the signal will have dissipated to zero.")]
        public float m_DissipationDistance = 100;

        /// <summary>The raw signal shape</summary>
        [Tooltip("The raw signal shape")]
        public AnimationCurve m_RawSignal;

        public enum RepeatMode
        {
            Stretch,
            Loop
        }
        public RepeatMode m_RepeatMode = RepeatMode.Stretch;

        private void OnValidate()
        {
            m_ImpactRadius = Mathf.Max(0, m_ImpactRadius);
            m_DissipationDistance = Mathf.Max(0, m_DissipationDistance);
            m_ImpactEnvelope.Validate();
        }

        /// <summary>Generate an impulse at a location in space</summary>
        public override void CreateEvent(Vector3 velocity, Vector3 pos, int channel = 1)
        {
            CinemachineImpulseManager.ImpulseEvent e 
                = CinemachineImpulseManager.Instance.NewImpulseEvent();
            e.m_Envelope = m_ImpactEnvelope;
            e.m_SignalSource = GetImpulse;
            e.m_SignalParameters = new object [] { velocity, Time.realtimeSinceStartup };
            e.m_Position = pos;
            e.m_Radius = m_ImpactRadius;
            e.m_Channel = Mathf.Abs(channel);
            e.m_DissipationMode = m_DissipationMode;
            e.m_DissipationDistance = m_DissipationDistance;
            CinemachineImpulseManager.Instance.AddImpulseEvent(e);
        }

        /// <summary>Get the raw signal from the Perlin Profile</summary>
        Vector3 GetImpulse(object[] parameters) 
        { 
            Vector3 signal = Vector3.zero;
            if (m_RawSignal != null && parameters != null && parameters.Length > 1 
                && parameters[0] is Vector3 && parameters[1] is float)
            {
                Vector3 velocity = (Vector3)parameters[0];
                float deltaTime = Time.realtimeSinceStartup - (float)parameters[1];

                var keys = m_RawSignal.keys;
                if (keys.Length > 0)
                {
                    float value = keys[0].value;
                    float start = keys[0].time;
                    float duration = keys[keys.Length-1].time - start;
                    if (duration > UnityVectorExtensions.Epsilon 
                        && m_ImpactEnvelope.Duration > UnityVectorExtensions.Epsilon)
                    {
                        switch (m_RepeatMode)
                        {
                            default:
                            case RepeatMode.Stretch:
                                value = m_RawSignal.Evaluate(start + (deltaTime / m_ImpactEnvelope.Duration) * duration);
                                break;
                            case RepeatMode.Loop:
                                value = m_RawSignal.Evaluate(start + (deltaTime % duration));
                                break;
                        }
                        signal = value * velocity;
                    }
                }
            }
            return signal; 
        }
    }
}
