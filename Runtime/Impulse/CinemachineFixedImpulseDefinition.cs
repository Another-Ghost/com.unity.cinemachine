using Cinemachine.Utility;
using UnityEngine;

namespace Cinemachine
{
    /// <summary>
    /// A definition of an impulse signal that gets propagated to listeners
    /// </summary>
    [DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
    [SaveDuringPlay]
    public class CinemachineFixedImpulseDefinition : CinemachineImpulseDefinition
    {
        /// <summary>
        /// This defines the time-envelope of the signal.  
        /// The raw signal generated by the profile will be scaled to fit in the envelope.
        /// </summary>
        [Tooltip("This defines the time-envelope of the signal.  The raw signal generated by the profile will be scaled to fit in the envelope.")]
        [CinemachineImpulseEnvelopeProperty]
        public CinemachineImpulseManager.EnvelopeDefinition m_ImpactEnvelope;

        /// <summary>
        /// The signal will have full amplitude in this radius surrounding the impact point.  
        /// Beyond that it will dissipate with distance.
        /// </summary>
        [Tooltip("The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]
        public float m_ImpactRadius = 1;

        /// <summary>
        /// This defines how the signal will dissipate with distance beyond the impact radius.  
        /// </summary>
        [Tooltip("This defines how the signal will dissipate with distance beyond the impact radius.")]
        public CinemachineImpulseManager.ImpulseEvent.DissipationMode m_DissipationMode 
            = CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;

        /// <summary>
        /// At this distance beyond the impact radius, the signal will have dissipated to zero.  
        /// </summary>
        [Tooltip("At this distance beyond the impact radius, the signal will have dissipated to zero.")]
        public float m_DissipationDistance = 100;

        /// <summary>The raw signal shape</summary>
        [Tooltip("The raw signal shape")]
        public AnimationCurve m_RawSignal;

        /// <summary>How to fit the curve into the envelope time</summary>
        public enum RepeatMode
        {
            /// <summary>Time-stretch the curve to fit the envelope</summary>
            Stretch,
            /// <summary>Loop the curve in time to fill the envelope</summary>
            Loop
        }
        /// <summary>How to fit the curve into the envelope time</summary>
        [Tooltip("How to fit the curve into the envelope time")]
        public RepeatMode m_RepeatMode = RepeatMode.Stretch;

        private void OnValidate()
        {
            m_ImpactRadius = Mathf.Max(0, m_ImpactRadius);
            m_DissipationDistance = Mathf.Max(0, m_DissipationDistance);
            m_ImpactEnvelope.Validate();
        }

        /// <summary>Generate an impulse at a location in space</summary>
        public override void CreateEvent(Vector3 velocity, Vector3 pos, int channel = 1)
        {
            if (m_RawSignal != null && m_ImpactEnvelope.Duration > UnityVectorExtensions.Epsilon)
            {
                CinemachineImpulseManager.ImpulseEvent e 
                    = CinemachineImpulseManager.Instance.NewImpulseEvent();
                e.m_Envelope = m_ImpactEnvelope;
                e.m_SignalSource = new SignalSource(
                    m_RawSignal, velocity, m_RepeatMode, m_ImpactEnvelope.Duration);
                e.m_Position = pos;
                e.m_Radius = m_ImpactRadius;
                e.m_Channel = Mathf.Abs(channel);
                e.m_DissipationMode = m_DissipationMode;
                e.m_DissipationDistance = m_DissipationDistance;
                CinemachineImpulseManager.Instance.AddImpulseEvent(e);
            }
        }

        class SignalSource : CinemachineImpulseManager.IRawSignalSource
        {
            AnimationCurve m_RawSignal;
            Vector3 m_Velocity;
            RepeatMode m_RepeatMode;
            float m_EnvelopeDuration;

            public SignalSource(
                AnimationCurve rawSignal, Vector3 velocity,
                RepeatMode repeatMode, float duration)
            {
                m_RawSignal = rawSignal;
                m_Velocity = velocity;
                m_RepeatMode = repeatMode;
                m_EnvelopeDuration = duration;
            }

            public Vector3 GetSignal(float timeSinceSignalStart)
            {
                Vector3 signal = Vector3.zero;
                var keys = m_RawSignal.keys;
                if (keys.Length > 0)
                {
                    float value = keys[0].value;
                    float start = keys[0].time;
                    float duration = keys[keys.Length-1].time - start;
                    if (duration > UnityVectorExtensions.Epsilon)
                    {
                        switch (m_RepeatMode)
                        {
                            default:
                            case RepeatMode.Stretch:
                                value = m_RawSignal.Evaluate(start + (timeSinceSignalStart / m_EnvelopeDuration) * duration);
                                break;
                            case RepeatMode.Loop:
                                value = m_RawSignal.Evaluate(start + (timeSinceSignalStart % duration));
                                break;
                        }
                        signal = value * m_Velocity;
                    }
                }
                return signal; 
            }
        }
    }
}
