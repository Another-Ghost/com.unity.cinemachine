using Cinemachine.Utility;
using UnityEngine;

namespace Cinemachine
{
    /// <summary>
    /// A definition of an impulse signal that gets propagated to listeners
    /// </summary>
    [DocumentationSorting(DocumentationSortingAttribute.Level.API)]
    [SaveDuringPlay]
    public class CinemachineFixedImpulseDefinition : CinemachineImpulseDefinition
    {
        /// <summary>
        /// This defines the time-envelope of the signal.  
        /// The raw signal generated by the profile will be scaled to fit in the envelope.
        /// </summary>
        [Tooltip("This defines the time-envelope of the signal.  The raw signal generated by the profile will be scaled to fit in the envelope.")]
        [CinemachineImpulseEnvelopeProperty]
        public CinemachineImpulseManager.EnvelopeDefinition m_ImpactEnvelope;

        /// <summary>
        /// The signal will have full amplitude in this radius surrounding the impact point.  
        /// Beyond that it will dissipate with distance.
        /// </summary>
        [Tooltip("The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]
        public float m_ImpactRadius = 1;

        /// <summary>
        /// This defines how the signal will dissipate with distance beyond the impact radius.  
        /// </summary>
        [Tooltip("This defines how the signal will dissipate with distance beyond the impact radius.")]
        public CinemachineImpulseManager.ImpulseEvent.DissipationMode m_DissipationMode 
            = CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;

        /// <summary>
        /// At this distance beyond the impact radius, the signal will have dissipated to zero.  
        /// </summary>
        [Tooltip("At this distance beyond the impact radius, the signal will have dissipated to zero.")]
        public float m_DissipationDistance = 100;

        /// <summary>
        /// The asset containing the Perlin Profile.  
        /// Define the frequencies and amplitudes there to make a signal profile
        /// </summary>
        [Tooltip("The asset containing the Perlin Profile.  Define the frequencies and amplitudes there to make a make a signal profile.  Make your own or just use one of the many presets.")]
        [NoiseSettingsProperty]
        public NoiseSettings m_PerlinProfile;

        /// <summary>
        /// Gain to apply to the amplitudes defined in the Perlin Profile asset.
        /// </summary>
        [Tooltip("Gain to apply to the amplitudes defined in the Perlin Profile asset.  1 is normal.  Setting this to 0 completely mutes the signal.")]
        public float m_AmplitudeGain = 1f;

        /// <summary>
        /// Scale factor to apply to the frequencies defined in the Perlin Profile asset.
        /// </summary>
        [Tooltip("Scale factor to apply to the frequencies defined in the Perlin Profile asset.  1 is normal.  Larger magnitudes will make the signal shake more rapidly.")]
        public float m_FrequencyGain = 1f;

        private void OnValidate()
        {
            m_ImpactRadius = Mathf.Max(0, m_ImpactRadius);
            m_DissipationDistance = Mathf.Max(0, m_DissipationDistance);
            m_AmplitudeGain = Mathf.Max(0, m_AmplitudeGain);
            m_FrequencyGain = Mathf.Max(0, m_FrequencyGain);
            m_ImpactEnvelope.Validate();
        }

        /// <summary>Generate an impulse at a location in space</summary>
        public override void CreateEvent(Vector3 velocity, Vector3 pos, int channel = 1)
        {
            CinemachineImpulseManager.ImpulseEvent e 
                = CinemachineImpulseManager.Instance.NewImpulseEvent();
            e.m_Envelope = m_ImpactEnvelope;
            e.m_SignalSource = GetImpulse;
            e.m_SignalParameters = new object [] { velocity };
            e.m_Position = pos;
            e.m_Radius = m_ImpactRadius;
            e.m_Channel = Mathf.Abs(channel);
            e.m_DissipationMode = m_DissipationMode;
            e.m_DissipationDistance = m_DissipationDistance;
            CinemachineImpulseManager.Instance.AddImpulseEvent(e);
        }

        /// <summary>Get the raw signal from the Perlin Profile</summary>
        Vector3 GetImpulse(object[] parameters) 
        { 
            Vector3 signal = Vector3.zero;
            if (!mInitialized)
                Initialize();
            if (m_PerlinProfile != null)
            {
                // Use whatever channel is more defined (kinda hacky I know)
                NoiseSettings.TransformNoiseParams[] profile 
                    = m_PerlinProfile.PositionNoise.Length > m_PerlinProfile.OrientationNoise.Length
                        ? m_PerlinProfile.PositionNoise : m_PerlinProfile.OrientationNoise;

                float time = (Time.realtimeSinceStartup - mNoiseStartTime) * m_FrequencyGain;
                signal = NoiseSettings.GetCombinedFilterResults(
                    profile, time, mNoiseOffsets) * m_AmplitudeGain;
                if (parameters != null && parameters.Length > 0 && parameters[0] is Vector3)
                {
                    Vector3 velocity = (Vector3)parameters[0];
                    float gain = velocity.magnitude;
                    signal *= gain;
                    if (gain > UnityVectorExtensions.Epsilon)
                    {
                        Quaternion rot = Quaternion.FromToRotation(Vector3.up, velocity);
                        signal = rot * signal;
                    }
                }
            }
            return signal; 
        }

        private bool mInitialized = false;
        private float mNoiseStartTime = 0;
        private Vector3 mNoiseOffsets = Vector3.zero;

        void Initialize()
        {
            mInitialized = true;
            mNoiseStartTime = Time.realtimeSinceStartup;
            mNoiseOffsets = new Vector3(
                    Random.Range(-1000f, 1000f),
                    Random.Range(-1000f, 1000f),
                    Random.Range(-1000f, 1000f));
        }
    }
}
