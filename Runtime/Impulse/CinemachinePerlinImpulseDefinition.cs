using Cinemachine.Utility;
using UnityEngine;

namespace Cinemachine
{
    /// <summary>
    /// A definition of an impulse signal that gets propagated to listeners
    /// </summary>
    [DocumentationSorting(DocumentationSortingAttribute.Level.UserRef)]
    public class CinemachinePerlinImpulseDefinition : CinemachineImpulseDefinition
    {
        /// <summary>
        /// This defines the time-envelope of the signal.  
        /// The raw signal generated by the profile will be scaled to fit in the envelope.
        /// </summary>
        [Tooltip("This defines the time-envelope of the signal.  The raw signal generated by the profile will be scaled to fit in the envelope.")]
        [CinemachineImpulseEnvelopeProperty]
        public CinemachineImpulseManager.EnvelopeDefinition m_ImpactEnvelope;

        /// <summary>
        /// The signal will have full amplitude in this radius surrounding the impact point.  
        /// Beyond that it will dissipate with distance.
        /// </summary>
        [Tooltip("The signal will have full amplitude in this radius surrounding the impact point.  Beyond that it will dissipate with distance.")]
        public float m_ImpactRadius = 1;

        /// <summary>
        /// This defines how the signal will dissipate with distance beyond the impact radius.  
        /// </summary>
        [Tooltip("This defines how the signal will dissipate with distance beyond the impact radius.")]
        public CinemachineImpulseManager.ImpulseEvent.DissipationMode m_DissipationMode 
            = CinemachineImpulseManager.ImpulseEvent.DissipationMode.ExponentialDecay;

        /// <summary>
        /// At this distance beyond the impact radius, the signal will have dissipated to zero.  
        /// </summary>
        [Tooltip("At this distance beyond the impact radius, the signal will have dissipated to zero.")]
        public float m_DissipationDistance = 100;

        /// <summary>
        /// The asset containing the Perlin Profile.  
        /// Define the frequencies and amplitudes there to make a signal profile
        /// </summary>
        [Tooltip("The asset containing the Perlin Profile.  Define the frequencies and amplitudes there to make a make a signal profile.  Make your own or just use one of the many presets.")]
        [NoiseSettingsProperty]
        public NoiseSettings m_PerlinProfile;

        /// <summary>
        /// Gain to apply to the amplitudes defined in the Perlin Profile asset.
        /// </summary>
        [Tooltip("Gain to apply to the amplitudes defined in the Perlin Profile asset.  1 is normal.  Setting this to 0 completely mutes the signal.")]
        public float m_AmplitudeGain = 1f;

        /// <summary>
        /// Scale factor to apply to the frequencies defined in the Perlin Profile asset.
        /// </summary>
        [Tooltip("Scale factor to apply to the frequencies defined in the Perlin Profile asset.  1 is normal.  Larger magnitudes will make the signal shake more rapidly.")]
        public float m_FrequencyGain = 1f;

        private void OnValidate()
        {
            m_ImpactRadius = Mathf.Max(0, m_ImpactRadius);
            m_DissipationDistance = Mathf.Max(0, m_DissipationDistance);
            m_AmplitudeGain = Mathf.Max(0, m_AmplitudeGain);
            m_FrequencyGain = Mathf.Max(0, m_FrequencyGain);
            m_ImpactEnvelope.Validate();
        }

        /// <summary>Generate an impulse at a location in space</summary>
        public override void CreateEvent(Vector3 velocity, Vector3 pos, int channel = 1)
        {
            if (m_PerlinProfile != null)
            {
                CinemachineImpulseManager.ImpulseEvent e 
                    = CinemachineImpulseManager.Instance.NewImpulseEvent();
                e.m_Envelope = m_ImpactEnvelope;
                e.m_SignalSource = new SignalSource(
                    m_PerlinProfile, velocity, m_AmplitudeGain, m_FrequencyGain);
                e.m_Position = pos;
                e.m_Radius = m_ImpactRadius;
                e.m_Channel = Mathf.Abs(channel);
                e.m_DissipationMode = m_DissipationMode;
                e.m_DissipationDistance = m_DissipationDistance;
                CinemachineImpulseManager.Instance.AddImpulseEvent(e);
            }
        }

        class SignalSource : CinemachineImpulseManager.IRawSignalSource
        {
            NoiseSettings m_PerlinProfile;
            Vector3 m_Velocity;
            float m_AmplitudeGain;
            float m_FrequencyGain;

            public SignalSource(
                NoiseSettings perlinProfile, Vector3 velocity,
                float amplitudeGain, float frequencyGain)
            {
                m_PerlinProfile = perlinProfile;
                m_Velocity = velocity;
                m_AmplitudeGain = amplitudeGain;
                m_FrequencyGain = frequencyGain;
            }

            public Vector3 GetSignal(float timeSinceSignalStart)
            {
                Vector3 signal = Vector3.zero;

                // Use whatever channel is more defined (kinda hacky I know)
                NoiseSettings.TransformNoiseParams[] profile 
                    = m_PerlinProfile.PositionNoise.Length > m_PerlinProfile.OrientationNoise.Length
                        ? m_PerlinProfile.PositionNoise : m_PerlinProfile.OrientationNoise;

                float time = timeSinceSignalStart * m_FrequencyGain;
                signal = NoiseSettings.GetCombinedFilterResults(
                    profile, time, mNoiseOffsets) * m_AmplitudeGain;
                float gain = m_Velocity.magnitude;
                signal *= gain;
                if (gain > UnityVectorExtensions.Epsilon)
                {
                    Quaternion rot = Quaternion.FromToRotation(Vector3.up, m_Velocity);
                    signal = rot * signal;
                }
                return signal; 
            }
    
            bool mInitialized = false;
            Vector3 mNoiseOffsets = Vector3.zero;

            void Initialize()
            {
                mInitialized = true;
                mNoiseOffsets = new Vector3(
                        Random.Range(-1000f, 1000f),
                        Random.Range(-1000f, 1000f),
                        Random.Range(-1000f, 1000f));
            }
        }
    }
}
